<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CamOrder</title>
  <style>
    :root {
      --bg-0: #0e1217;
      --bg-1: #141a21;
      --panel: #1d242d;
      --panel-hi: #242d38;
      --panel-edge: #2c3744;
      --text: #e6ecf3;
      --muted: #98a6b3;
      --accent: #4ad38a;
      --accent-2: #3aa2ff;
      --danger: #ff4d4d;
      --warning: #f2c94c;
      --shadow: rgba(0, 0, 0, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Trebuchet MS", "Lucida Sans Unicode", "Tahoma", sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 20% 10%, rgba(58, 162, 255, 0.12), transparent 60%),
        radial-gradient(900px 500px at 85% 15%, rgba(74, 211, 138, 0.12), transparent 65%),
        linear-gradient(160deg, var(--bg-0), var(--bg-1));
      height: 100vh;
      overflow: hidden;
    }

    #app {
      height: 100vh;
      display: grid;
      grid-template-rows: 68px 1fr 320px;
      gap: 8px;
      padding: 10px;
    }

    #topbar {
      display: grid;
      grid-template-columns: 1.6fr 1.2fr 1.2fr;
      gap: 10px;
      align-items: center;
      padding: 8px 12px;
      background: linear-gradient(180deg, var(--panel-hi), var(--panel));
      border: 1px solid var(--panel-edge);
      box-shadow: 0 8px 20px var(--shadow);
      border-radius: 10px;
      animation: rise-in 0.5s ease-out;
    }

    @keyframes rise-in {
      from {
        opacity: 0;
        transform: translateY(6px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .transport-group {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .transport-group label {
      font-size: 12px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    button, select, input[type="text"], input[type="number"] {
      background: var(--panel-hi);
      color: var(--text);
      border: 1px solid var(--panel-edge);
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 12px;
      outline: none;
    }

    button {
      cursor: pointer;
      transition: transform 0.12s ease, background 0.2s ease, border-color 0.2s ease;
    }

    button:hover {
      background: #2a3541;
      border-color: #3a4756;
    }

    button:active {
      transform: translateY(1px);
    }

    button.primary {
      background: var(--accent-2);
      border-color: rgba(58, 162, 255, 0.6);
      color: #081b2d;
      font-weight: 700;
    }

    button.danger {
      background: var(--danger);
      border-color: #ff7a7a;
      color: #2b0b0b;
      font-weight: 700;
    }

    button.ghost {
      background: transparent;
      border: 1px dashed var(--panel-edge);
      color: var(--muted);
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    #recIndicator {
      padding: 4px 8px;
      border-radius: 6px;
      background: rgba(255, 77, 77, 0.15);
      color: var(--danger);
      font-weight: 700;
      letter-spacing: 1px;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    #timeDisplay {
      font-family: "Lucida Console", "Courier New", monospace;
      font-size: 13px;
      background: #0f141a;
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #26303b;
    }

    #content {
      display: grid;
      grid-template-columns: var(--left-width, 250px) 1fr var(--right-width, 300px);
      gap: 8px;
      min-height: 0;
    }

    .panel {
      background: linear-gradient(180deg, #1a222b, #182029);
      border: 1px solid var(--panel-edge);
      border-radius: 10px;
      box-shadow: 0 8px 20px var(--shadow);
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .panel-header {
      padding: 10px 12px;
      border-bottom: 1px solid #25303b;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .panel-header h3 {
      margin: 0;
      font-size: 13px;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: var(--muted);
    }

    .panel-body {
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .collapse-toggle {
      background: transparent;
      border: 1px solid #2c3744;
      color: var(--muted);
      border-radius: 6px;
      padding: 4px 6px;
      font-size: 12px;
    }

    .panel.collapsed {
      min-width: 44px;
    }

    .panel.collapsed .panel-body {
      display: none;
    }

    .panel.collapsed .panel-header h3,
    .panel.collapsed .panel-header .transport-group button:not(.collapse-toggle),
    .panel.collapsed .panel-header .transport-group label,
    .panel.collapsed .panel-header .transport-group input,
    .panel.collapsed .panel-header .transport-group select {
      display: none;
    }

    #binList {
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      overflow: auto;
      flex: 1;
    }

    .bin-item {
      padding: 8px 10px;
      border-radius: 6px;
      background: #131820;
      border: 1px solid transparent;
      display: grid;
      gap: 4px;
      cursor: pointer;
    }

    .bin-item.missing {
      border-color: rgba(242, 201, 76, 0.6);
    }

    .bin-item.selected {
      border-color: var(--accent-2);
      background: rgba(58, 162, 255, 0.15);
    }

    .bin-title {
      font-weight: 700;
      font-size: 12px;
    }

    .bin-meta {
      color: var(--muted);
      font-size: 11px;
    }

    #monitorFrame {
      position: relative;
      background: #06080b;
      border-radius: 12px;
      margin: 10px;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      min-height: 180px;
      cursor: grab;
    }

    #programVideo {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
      display: none;
    }

    #monitorPlaceholder {
      color: var(--muted);
      font-size: 13px;
    }

    #inspectorContent {
      padding: 10px 12px;
      overflow: auto;
      flex: 1;
    }

    .field {
      margin-bottom: 10px;
      display: grid;
      gap: 4px;
    }

    .field label {
      font-size: 11px;
      color: var(--muted);
    }

    .readonly {
      padding: 6px 8px;
      background: #0f141a;
      border-radius: 6px;
      border: 1px solid #26303b;
      font-size: 12px;
      font-family: "Lucida Console", "Courier New", monospace;
    }

    .project-actions {
      padding: 8px 12px;
      display: grid;
      gap: 6px;
    }

    #exportNotes {
      font-size: 11px;
      color: var(--muted);
      line-height: 1.4;
      background: #10161d;
      border-radius: 6px;
      padding: 8px;
      border: 1px dashed #2a3541;
      white-space: pre-wrap;
    }

    #timelineSection {
      background: linear-gradient(180deg, #141b23, #10161d);
      border: 1px solid var(--panel-edge);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      min-height: 0;
      box-shadow: 0 8px 20px var(--shadow);
    }

    #timelineToolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-bottom: 1px solid #25303b;
    }

    #timelineBody {
      flex: 1;
      display: grid;
      grid-template-columns: 210px 1fr;
      min-height: 0;
    }

    #trackHeaders {
      overflow: auto;
      border-right: 1px solid #25303b;
      background: #11161d;
    }

    .track-header {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px;
      align-items: center;
      padding: 10px 8px;
      border-bottom: 1px solid #1f2731;
      height: 70px;
    }

    .track-header.selected {
      background: rgba(58, 162, 255, 0.15);
    }

    .track-name {
      width: 100%;
      background: #0e141b;
      border: 1px solid #233040;
      color: var(--text);
      padding: 4px 6px;
      font-size: 12px;
    }

    .track-controls {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .track-btn {
      padding: 4px 6px;
      font-size: 10px;
      border-radius: 5px;
    }

    .track-btn.armed {
      background: rgba(255, 77, 77, 0.2);
      border-color: rgba(255, 77, 77, 0.6);
      color: #ffb3b3;
    }

    .track-btn.hidden {
      background: rgba(152, 166, 179, 0.15);
      color: var(--muted);
    }

    #timelineScroll {
      overflow: auto;
      position: relative;
    }

    #timelineInner {
      position: relative;
      min-height: 100%;
    }

    #ruler {
      position: absolute;
      top: 0;
      left: 0;
      height: 28px;
      background: #0e141b;
    }

    #tracksLane {
      position: absolute;
      top: 28px;
      left: 0;
      width: 100%;
    }

    .track-row {
      position: relative;
      height: 70px;
      border-bottom: 1px solid #1f2731;
      background: #0f151d;
    }

    .track-row.hidden {
      opacity: 0.35;
    }

    .clip {
      position: absolute;
      top: 10px;
      height: 50px;
      border-radius: 6px;
      background: linear-gradient(135deg, rgba(58, 162, 255, 0.4), rgba(58, 162, 255, 0.15));
      border: 1px solid rgba(58, 162, 255, 0.6);
      display: grid;
      align-items: center;
      padding: 0 10px;
      cursor: grab;
      color: #dbe9ff;
      font-size: 12px;
      overflow: hidden;
    }

    .clip.selected {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(74, 211, 138, 0.3);
    }

    .clip-label {
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .handle {
      position: absolute;
      top: 0;
      width: 6px;
      height: 100%;
      background: rgba(255, 255, 255, 0.15);
      cursor: ew-resize;
    }

    .handle.left {
      left: 0;
      border-radius: 6px 0 0 6px;
    }

    .handle.right {
      right: 0;
      border-radius: 0 6px 6px 0;
    }

    #playhead {
      position: absolute;
      top: 0;
      width: 2px;
      background: var(--danger);
      height: 100%;
      pointer-events: auto;
      cursor: ew-resize;
    }

    .status-pill {
      padding: 3px 6px;
      border-radius: 999px;
      font-size: 11px;
      background: rgba(74, 211, 138, 0.15);
      color: var(--accent);
      border: 1px solid rgba(74, 211, 138, 0.4);
    }

    .status-pill.warn {
      background: rgba(242, 201, 76, 0.15);
      color: var(--warning);
      border-color: rgba(242, 201, 76, 0.4);
    }

    .status-pill.off {
      background: rgba(152, 166, 179, 0.1);
      color: var(--muted);
      border-color: rgba(152, 166, 179, 0.3);
    }

    .status-pill.live {
      background: rgba(255, 77, 77, 0.15);
      color: var(--danger);
      border-color: rgba(255, 77, 77, 0.5);
    }

    @media (max-width: 1100px) {
      #topbar {
        grid-template-columns: 1fr;
        row-gap: 8px;
      }

      #content {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
      }

      #timelineBody {
        grid-template-columns: 1fr;
      }

      #trackHeaders {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <header id="topbar">
      <div class="transport-group">
        <button id="playBtn" class="primary">Play</button>
        <button id="stopBtn" class="ghost">Stop</button>
        <button id="recordBtn" class="danger">Record</button>
        <span id="recIndicator">REC</span>
        <span id="timeDisplay">00:00:00:00</span>
        <label>FPS
          <select id="fpsSelect">
            <option value="24">24</option>
            <option value="25">25</option>
            <option value="30" selected>30</option>
            <option value="60">60</option>
          </select>
        </label>
        <label>Zoom
          <input id="zoomSlider" type="range" min="20" max="400" value="120" />
        </label>
      </div>
      <div class="transport-group">
        <label>Camera
          <select id="cameraSelect"></select>
        </label>
        <label>Resolution
          <select id="resolutionSelect"></select>
        </label>
        <button id="refreshDevices" class="ghost">Refresh</button>
        <button id="enableCameraBtn" class="ghost">Enable Camera</button>
        <span id="cameraStatus" class="status-pill off">Camera Off</span>
      </div>
      <div class="transport-group">
        <label>MIDI In
          <select id="midiInputSelect"></select>
        </label>
        <label>Mode
          <select id="midiModeSelect">
            <option value="clock">MIDI Clock</option>
            <option value="mtc">MTC</option>
            <option value="mmc">MMC</option>
          </select>
        </label>
        <button id="midiConnectBtn" class="ghost">Enable MIDI</button>
        <span id="midiStatus" class="status-pill off">MIDI Off</span>
      </div>
    </header>

    <section id="content">
      <aside id="bin" class="panel collapsible collapsed">
        <div class="panel-header">
          <h3>Project Bin</h3>
          <div class="transport-group">
            <button id="importVideoBtn" class="ghost">Import Video</button>
            <button id="importAudioBtn" class="ghost">Import Master Audio</button>
            <button class="collapse-toggle" data-panel="bin" aria-expanded="false">▸</button>
          </div>
        </div>
        <div class="panel-body" data-panel-body="bin">
          <div id="binList"></div>
          <div class="panel-header">
            <button id="insertToTrackBtn" class="primary">Insert to Selected Track</button>
          </div>
        </div>
      </aside>

      <section id="monitor" class="panel">
        <div class="panel-header">
          <h3>Program Monitor</h3>
          <span id="transportMode" class="status-pill off">Manual</span>
        </div>
        <div id="monitorFrame">
          <video id="programVideo" muted playsinline></video>
          <div id="monitorPlaceholder">No video at playhead</div>
        </div>
      </section>

      <aside id="inspector" class="panel collapsible collapsed">
        <div class="panel-header">
          <h3>Inspector</h3>
          <button class="collapse-toggle" data-panel="inspector" aria-expanded="false">▸</button>
        </div>
        <div class="panel-body" data-panel-body="inspector">
          <div id="inspectorContent">Select a clip or placement.</div>
          <div class="panel-header">
            <h3>Project</h3>
          </div>
          <div class="project-actions">
            <button id="chooseFolderBtn" class="ghost">Choose Project Folder</button>
            <button id="saveProjectBtn" class="ghost">Save Project</button>
            <button id="loadProjectBtn" class="ghost">Load Project JSON</button>
            <input id="loadProjectInput" type="file" accept=".json" hidden />
            <button id="relinkBtn" class="ghost">Relink Media</button>
            <input id="relinkInput" type="file" multiple hidden />
            <button id="downloadProjectBtn" class="ghost">Download Project JSON</button>
            <button id="downloadClipsBtn" class="ghost">Download Recorded Clips</button>
          </div>
          <div class="panel-header">
            <h3>Export</h3>
          </div>
          <div class="project-actions">
            <button id="exportEdlBtn" class="ghost">Export Timeline JSON/EDL</button>
            <button id="renderPreviewBtn" class="primary">Render Preview WebM</button>
            <div id="exportNotes"></div>
          </div>
        </div>
      </aside>
    </section>

    <section id="timelineSection">
      <div id="timelineToolbar">
        <button id="addTrackBtn" class="ghost">Add Track</button>
        <button id="splitBtn" class="ghost">Split at Playhead</button>
        <button id="deletePlacementBtn" class="ghost">Delete Placement</button>
      </div>
      <div id="timelineBody">
        <div id="trackHeaders"></div>
        <div id="timelineScroll">
          <div id="timelineInner">
            <canvas id="ruler"></canvas>
            <div id="playhead"></div>
            <div id="tracksLane"></div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <input id="importVideoInput" type="file" accept="video/*" hidden />
  <input id="importAudioInput" type="file" accept="audio/*" hidden />

  <script>
    (() => {
      'use strict';

      // Timecode utilities
      const pad = (num, size = 2) => String(num).padStart(size, '0');

      function secondsToSMPTE(seconds, fps) {
        const safe = Math.max(0, seconds || 0);
        const totalFrames = Math.floor(safe * fps + 1e-6);
        const frames = totalFrames % fps;
        const totalSeconds = Math.floor(totalFrames / fps);
        const secs = totalSeconds % 60;
        const mins = Math.floor(totalSeconds / 60) % 60;
        const hours = Math.floor(totalSeconds / 3600);
        return `${pad(hours)}:${pad(mins)}:${pad(secs)}:${pad(frames)}`;
      }

      function smpteToSeconds(tc, fps) {
        if (!tc) return 0;
        const parts = tc.trim().split(':').map(Number);
        if (parts.length !== 4 || parts.some((part) => Number.isNaN(part))) return 0;
        const [hours, mins, secs, frames] = parts;
        return hours * 3600 + mins * 60 + secs + frames / fps;
      }

      const RULER_HEIGHT = 28;
      const TRACK_HEIGHT = 70;
      const MIN_DURATION = 10;
      const ZOOM_MIN = 20;
      const ZOOM_MAX = 400;

      const state = {
        settings: {
          fps: 30,
          pxPerSecond: 120,
          createdAt: new Date().toISOString(),
        },
        transport: {
          state: 'stop',
          playheadSeconds: 0,
          basePlayheadSeconds: 0,
          baseRealTime: performance.now(),
          source: 'manual',
        },
        tracks: [],
        clips: [],
        placements: [],
        selectedPlacementId: null,
        selectedClipId: null,
        selectedTrackId: null,
        masterAudio: {
          file: null,
          name: '',
          startSeconds: 0,
          filename: '',
        },
        camera: {
          status: 'off',
          lastError: '',
        },
        projectHandle: null,
        mediaCache: new Map(),
        videoCache: new Map(),
        recording: {
          active: false,
          pending: false,
        },
        midi: {
          access: null,
          input: null,
          mode: 'clock',
          connected: false,
          clock: {
            lastTick: 0,
            bpm: 120,
            playing: false,
          },
          mtc: {
            qf: Array(8).fill(0),
            lastUpdate: 0,
            active: false,
          },
        },
        preview: {
          lastUpdate: 0,
          activeClipId: null,
          activePlacementId: null,
        },
        ui: {
          binCollapsed: true,
          inspectorCollapsed: true,
        },
        dirty: false,
      };

      const dom = {};

      function cacheDom() {
        dom.playBtn = document.getElementById('playBtn');
        dom.stopBtn = document.getElementById('stopBtn');
        dom.recordBtn = document.getElementById('recordBtn');
        dom.recIndicator = document.getElementById('recIndicator');
        dom.timeDisplay = document.getElementById('timeDisplay');
        dom.fpsSelect = document.getElementById('fpsSelect');
        dom.zoomSlider = document.getElementById('zoomSlider');
        dom.cameraSelect = document.getElementById('cameraSelect');
        dom.resolutionSelect = document.getElementById('resolutionSelect');
        dom.refreshDevices = document.getElementById('refreshDevices');
        dom.enableCameraBtn = document.getElementById('enableCameraBtn');
        dom.cameraStatus = document.getElementById('cameraStatus');
        dom.midiInputSelect = document.getElementById('midiInputSelect');
        dom.midiModeSelect = document.getElementById('midiModeSelect');
        dom.midiConnectBtn = document.getElementById('midiConnectBtn');
        dom.midiStatus = document.getElementById('midiStatus');
        dom.transportMode = document.getElementById('transportMode');
        dom.content = document.getElementById('content');
        dom.binPanel = document.getElementById('bin');
        dom.inspectorPanel = document.getElementById('inspector');
        dom.monitorFrame = document.getElementById('monitorFrame');
        dom.binList = document.getElementById('binList');
        dom.programVideo = document.getElementById('programVideo');
        dom.monitorPlaceholder = document.getElementById('monitorPlaceholder');
        dom.inspectorContent = document.getElementById('inspectorContent');
        dom.chooseFolderBtn = document.getElementById('chooseFolderBtn');
        dom.saveProjectBtn = document.getElementById('saveProjectBtn');
        dom.loadProjectBtn = document.getElementById('loadProjectBtn');
        dom.loadProjectInput = document.getElementById('loadProjectInput');
        dom.relinkBtn = document.getElementById('relinkBtn');
        dom.relinkInput = document.getElementById('relinkInput');
        dom.downloadProjectBtn = document.getElementById('downloadProjectBtn');
        dom.downloadClipsBtn = document.getElementById('downloadClipsBtn');
        dom.exportEdlBtn = document.getElementById('exportEdlBtn');
        dom.renderPreviewBtn = document.getElementById('renderPreviewBtn');
        dom.exportNotes = document.getElementById('exportNotes');
        dom.addTrackBtn = document.getElementById('addTrackBtn');
        dom.splitBtn = document.getElementById('splitBtn');
        dom.deletePlacementBtn = document.getElementById('deletePlacementBtn');
        dom.trackHeaders = document.getElementById('trackHeaders');
        dom.timelineScroll = document.getElementById('timelineScroll');
        dom.timelineInner = document.getElementById('timelineInner');
        dom.ruler = document.getElementById('ruler');
        dom.playhead = document.getElementById('playhead');
        dom.tracksLane = document.getElementById('tracksLane');
        dom.importVideoBtn = document.getElementById('importVideoBtn');
        dom.importAudioBtn = document.getElementById('importAudioBtn');
        dom.insertToTrackBtn = document.getElementById('insertToTrackBtn');
        dom.importVideoInput = document.getElementById('importVideoInput');
        dom.importAudioInput = document.getElementById('importAudioInput');
      }

      function makeId(prefix) {
        return `${prefix}-${Math.random().toString(36).slice(2, 9)}`;
      }

      function defaultTransform() {
        return { scale: 1, offsetX: 0, offsetY: 0 };
      }

      function markDirty() {
        state.dirty = true;
      }

      function timeToPx(seconds) {
        return seconds * state.settings.pxPerSecond;
      }

      function pxToTime(px) {
        return px / state.settings.pxPerSecond;
      }

      function snapSeconds(seconds) {
        const frame = 1 / state.settings.fps;
        return Math.round(seconds / frame) * frame;
      }

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function setZoom(newZoom, anchorPx = null) {
        const previous = state.settings.pxPerSecond;
        const next = clamp(newZoom, ZOOM_MIN, ZOOM_MAX);
        if (next === previous) return;
        const scrollLeft = dom.timelineScroll.scrollLeft;
        const anchor = anchorPx === null ? 0 : anchorPx;
        const anchorTime = pxToTime(scrollLeft + anchor);
        state.settings.pxPerSecond = next;
        dom.zoomSlider.value = String(next);
        renderTimelineMetrics();
        if (anchorPx !== null) {
          dom.timelineScroll.scrollLeft = anchorTime * next - anchor;
        }
      }

      function getTimelineDurationSeconds() {
        let maxEnd = 0;
        for (const placement of state.placements) {
          const end = placement.timelineStartSeconds + placement.durationSeconds;
          if (end > maxEnd) maxEnd = end;
        }
        return Math.max(MIN_DURATION, maxEnd + 1);
      }

      function getTrackById(trackId) {
        return state.tracks.find((track) => track.id === trackId);
      }

      function getClipById(clipId) {
        return state.clips.find((clip) => clip.id === clipId);
      }

      function getPlacementById(placementId) {
        return state.placements.find((placement) => placement.id === placementId);
      }

      function getVisiblePlacementAtTime(seconds) {
        const visibleTracks = state.tracks
          .filter((track) => track.visible)
          .sort((a, b) => a.order - b.order);
        for (let i = visibleTracks.length - 1; i >= 0; i -= 1) {
          const track = visibleTracks[i];
          const placement = state.placements.find((item) => {
            if (item.trackId !== track.id) return false;
            const end = item.timelineStartSeconds + item.durationSeconds;
            return seconds >= item.timelineStartSeconds && seconds <= end;
          });
          if (placement) return placement;
        }
        return null;
      }

      function updateTrackOrder() {
        state.tracks.forEach((track, index) => {
          track.order = index;
        });
      }

      function addTrack(afterTrackId = null) {
        const trackNumber = state.tracks.length + 1;
        const newTrack = {
          id: makeId('track'),
          name: `V${trackNumber}`,
          armed: false,
          visible: true,
          order: state.tracks.length,
        };

        if (afterTrackId) {
          const index = state.tracks.findIndex((track) => track.id === afterTrackId);
          if (index >= 0) {
            state.tracks.splice(index + 1, 0, newTrack);
          } else {
            state.tracks.push(newTrack);
          }
        } else {
          state.tracks.push(newTrack);
        }

        updateTrackOrder();
        state.selectedTrackId = newTrack.id;
        markDirty();
        renderTracks();
      }

      function deleteTrack(trackId) {
        const hasPlacements = state.placements.some((placement) => placement.trackId === trackId);
        if (hasPlacements) {
          const ok = window.confirm('Delete this track and its placements?');
          if (!ok) return;
        }
        state.placements = state.placements.filter((placement) => placement.trackId !== trackId);
        state.tracks = state.tracks.filter((track) => track.id !== trackId);
        updateTrackOrder();
        if (state.selectedTrackId === trackId) state.selectedTrackId = null;
        if (state.selectedPlacementId) {
          const stillExists = state.placements.some((placement) => placement.id === state.selectedPlacementId);
          if (!stillExists) state.selectedPlacementId = null;
        }
        markDirty();
        renderAll();
      }

      function selectTrack(trackId) {
        state.selectedTrackId = trackId;
        renderTracks();
      }

      function selectPlacement(placementId) {
        state.selectedPlacementId = placementId;
        state.selectedClipId = null;
        renderTracks();
        renderBin();
        renderInspector();
      }

      function selectClip(clipId) {
        state.selectedClipId = clipId;
        state.selectedPlacementId = null;
        renderTracks();
        renderBin();
        renderInspector();
      }

      function setPlayhead(seconds) {
        const snapped = Math.max(0, snapSeconds(seconds));
        state.transport.playheadSeconds = snapped;
        state.transport.basePlayheadSeconds = snapped;
        state.transport.baseRealTime = performance.now();
        updatePlayheadUI();
      }

      function updatePlayheadUI() {
        dom.playhead.style.left = `${timeToPx(state.transport.playheadSeconds)}px`;
        dom.timeDisplay.textContent = secondsToSMPTE(state.transport.playheadSeconds, state.settings.fps);
      }

      function setTransportState(nextState) {
        state.transport.state = nextState;
        state.transport.basePlayheadSeconds = state.transport.playheadSeconds;
        state.transport.baseRealTime = performance.now();
        updateTransportUI();
      }

      function updateTransportUI() {
        const recording = state.transport.state === 'record';
        dom.recIndicator.style.opacity = recording ? 1 : 0;
        dom.playBtn.classList.toggle('active', state.transport.state === 'play');
        dom.recordBtn.classList.toggle('active', recording);
        updateExportNotes();
      }

      function updatePanelLayout() {
        const leftWidth = state.ui.binCollapsed ? 48 : 250;
        const rightWidth = state.ui.inspectorCollapsed ? 48 : 300;
        dom.content.style.setProperty('--left-width', `${leftWidth}px`);
        dom.content.style.setProperty('--right-width', `${rightWidth}px`);
      }

      function setPanelCollapsed(panelId, collapsed) {
        if (panelId === 'bin') state.ui.binCollapsed = collapsed;
        if (panelId === 'inspector') state.ui.inspectorCollapsed = collapsed;
        const panel = panelId === 'bin' ? dom.binPanel : dom.inspectorPanel;
        panel.classList.toggle('collapsed', collapsed);
        const toggle = panel.querySelector('.collapse-toggle');
        if (toggle) {
          toggle.textContent = collapsed ? '▸' : '▾';
          toggle.setAttribute('aria-expanded', String(!collapsed));
        }
        updatePanelLayout();
      }

      function setupPanelCollapseEvents() {
        document.querySelectorAll('.collapse-toggle').forEach((btn) => {
          btn.addEventListener('click', (event) => {
            event.stopPropagation();
            const panelId = btn.dataset.panel;
            if (!panelId) return;
            const isCollapsed = panelId === 'bin' ? state.ui.binCollapsed : state.ui.inspectorCollapsed;
            setPanelCollapsed(panelId, !isCollapsed);
          });
        });
      }

      function setManualControlsEnabled(enabled) {
        dom.playBtn.disabled = !enabled;
        dom.stopBtn.disabled = !enabled;
        dom.recordBtn.disabled = !enabled;
        dom.splitBtn.disabled = !enabled;
        dom.deletePlacementBtn.disabled = !enabled;
      }

      function updateExternalMode() {
        const midiConnected = !!state.midi.connected;
        if (midiConnected) {
          const modeLabel = state.midi.mode === 'clock' ? 'MIDI Clock'
            : state.midi.mode === 'mtc' ? 'MTC'
              : 'MMC';
          setTransportSource('external', modeLabel);
          return;
        }
        setTransportSource('manual', 'Manual');
      }

      function setTransportSource(source, label) {
        state.transport.source = source;
        const isExternal = source === 'external';
        setManualControlsEnabled(!isExternal);
        dom.transportMode.textContent = isExternal ? `External (${label || 'Link'})` : 'Manual';
        dom.transportMode.className = `status-pill ${isExternal ? 'warn' : 'off'}`;
      }

      function isManualMode() {
        return state.transport.source === 'manual';
      }

      async function startManualPlay() {
        if (!isManualMode()) return;
        if (state.transport.state === 'play') {
          stopTransport();
          return;
        }
        setTransportState('play');
      }

      async function startManualRecord() {
        if (!isManualMode()) return;
        if (state.transport.state === 'record') {
          stopTransport();
          return;
        }
        const ok = await startRecording();
        if (!ok) return;
        setTransportState('record');
      }

      function stopTransport() {
        if (state.transport.state === 'record') {
          stopRecording();
        }
        setTransportState('stop');
      }

      function refreshDevices() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
          dom.cameraSelect.innerHTML = '<option value="">No devices</option>';
          return Promise.resolve();
        }
        return navigator.mediaDevices.enumerateDevices().then((devices) => {
          const cameras = devices.filter((device) => device.kind === 'videoinput');
          dom.cameraSelect.innerHTML = '';
          const screenOption = document.createElement('option');
          screenOption.value = 'screen';
          screenOption.textContent = 'Screen / Window Capture';
          dom.cameraSelect.appendChild(screenOption);
          cameras.forEach((camera) => {
            const option = document.createElement('option');
            option.value = camera.deviceId;
            option.textContent = camera.label || `Camera ${dom.cameraSelect.length + 1}`;
            dom.cameraSelect.appendChild(option);
          });
          if (!cameras.length) {
            dom.cameraSelect.value = 'screen';
          }
          updateCameraSourceUI();
        }).catch(() => {
          dom.cameraSelect.innerHTML = '<option value="">Camera list blocked</option>';
        });
      }

      function populateResolutionOptions() {
        const presets = [
          { label: '640x480', width: 640, height: 480 },
          { label: '1280x720', width: 1280, height: 720 },
          { label: '1920x1080', width: 1920, height: 1080 },
          { label: '2560x1440', width: 2560, height: 1440 },
        ];
        dom.resolutionSelect.innerHTML = '';
        presets.forEach((preset) => {
          const option = document.createElement('option');
          option.value = `${preset.width}x${preset.height}`;
          option.textContent = preset.label;
          dom.resolutionSelect.appendChild(option);
        });
        dom.resolutionSelect.value = '1280x720';
      }

      function updateCameraSourceUI() {
        const isScreen = dom.cameraSelect.value === 'screen';
        dom.resolutionSelect.disabled = isScreen;
      }

      function setCameraStatus(status, message = '') {
        state.camera.status = status;
        state.camera.lastError = message;
        let text = 'Camera Off';
        let cls = 'status-pill off';
        if (status === 'ready') {
          text = 'Camera Ready';
          cls = 'status-pill';
        } else if (status === 'blocked') {
          text = 'Camera Blocked';
          cls = 'status-pill warn';
        } else if (status === 'busy') {
          text = 'Camera Busy';
          cls = 'status-pill warn';
        } else if (status === 'live') {
          text = 'Camera Live';
          cls = 'status-pill live';
        }
        dom.cameraStatus.textContent = text;
        dom.cameraStatus.className = cls;
      }

      async function warmUpCamera() {
        if (dom.cameraSelect.value === 'screen') {
          setCameraStatus('off');
          return;
        }
        setCameraStatus('busy');
        const stream = await getCameraStream();
        if (!stream) {
          setCameraStatus('blocked', 'Permission denied or unavailable.');
          return;
        }
        stream.getTracks().forEach((track) => track.stop());
        setCameraStatus('ready');
      }

      async function getCameraStream() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          alert('Camera capture is not supported in this browser.');
          setCameraStatus('blocked', 'getUserMedia unsupported.');
          return null;
        }
        try {
          setCameraStatus('busy');
          const source = dom.cameraSelect.value;
          let stream;
          if (source === 'screen') {
            if (!navigator.mediaDevices.getDisplayMedia) {
              alert('Screen capture is not supported in this browser.');
              setCameraStatus('blocked', 'getDisplayMedia unsupported.');
              return null;
            }
            stream = await navigator.mediaDevices.getDisplayMedia({
              video: true,
              audio: false,
            });
          } else {
            const [width, height] = dom.resolutionSelect.value.split('x').map(Number);
            const deviceId = source || undefined;
            stream = await navigator.mediaDevices.getUserMedia({
              video: {
                deviceId: deviceId ? { exact: deviceId } : undefined,
                width: { ideal: width },
                height: { ideal: height },
              },
              audio: false,
            });
          }
          return stream;
        } catch (error) {
          alert(`Unable to access camera: ${error.message}`);
          setCameraStatus('blocked', error.message);
          return null;
        }
      }

      function getSupportedMimeType() {
        const types = [
          'video/webm;codecs=vp9',
          'video/webm;codecs=vp8',
          'video/webm',
        ];
        for (const type of types) {
          if (MediaRecorder.isTypeSupported(type)) return type;
        }
        return '';
      }

      async function startRecording() {
        if (state.recording.active) return true;
        if (state.recording.pending) return false;
        state.recording.pending = true;
        const armedTracks = state.tracks.filter((track) => track.armed);
        if (!armedTracks.length) {
          alert('Arm at least one track before recording.');
          state.recording.pending = false;
          return false;
        }

        const stream = await getCameraStream();
        if (!stream) {
          state.recording.pending = false;
          return false;
        }
        setCameraStatus('live');

        const clipId = makeId('clip');
        const clipName = `Recording ${new Date().toLocaleTimeString()}`;
        const clip = {
          id: clipId,
          name: clipName,
          createdAt: new Date().toISOString(),
          durationSeconds: 0,
          source: 'recorded',
          filename: `${clipId}.webm`,
        };
        state.clips.push(clip);

        const placements = armedTracks.map((track) => {
          const placement = {
            id: makeId('plc'),
            clipId,
            trackId: track.id,
            timelineStartSeconds: state.transport.playheadSeconds,
            clipInSeconds: 0,
            clipOutSeconds: 0,
            durationSeconds: 0,
            transform: defaultTransform(),
          };
          state.placements.push(placement);
          return placement.id;
        });

        const mimeType = getSupportedMimeType();
        const recorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
        const chunks = [];

        recorder.ondataavailable = (event) => {
          if (event.data.size > 0) chunks.push(event.data);
        };

        recorder.onstop = () => {
          finalizeRecording({
            clipId,
            chunks,
            stream,
            durationSeconds: state.recording.currentDuration || 0,
            mimeType: recorder.mimeType,
          });
        };

        recorder.start(200);

        state.recording = {
          active: true,
          pending: false,
          clipId,
          placements,
          chunks,
          recorder,
          stream,
          startPlayhead: state.transport.playheadSeconds,
          currentDuration: 0,
        };

        markDirty();
        renderAll();
        return true;
      }

      function updateRecordingPlacements() {
        if (!state.recording.active) return;
        const elapsed = state.transport.playheadSeconds - state.recording.startPlayhead;
        const duration = Math.max(0, snapSeconds(elapsed));
        state.recording.currentDuration = duration;
        for (const placementId of state.recording.placements) {
          const placement = getPlacementById(placementId);
          if (!placement) continue;
          placement.durationSeconds = duration;
          placement.clipOutSeconds = placement.clipInSeconds + duration;
          updatePlacementElement(placement);
        }
      }

      function finalizeRecording(recording) {
        const clip = getClipById(recording.clipId);
        if (!clip) return;
        const blob = new Blob(recording.chunks, { type: recording.mimeType || 'video/webm' });
        clip.durationSeconds = recording.durationSeconds;
        const url = URL.createObjectURL(blob);
        state.mediaCache.set(clip.id, {
          blob,
          url,
          name: clip.name,
          filename: clip.filename,
          source: 'recorded',
        });

        for (const placementId of state.recording.placements) {
          const placement = getPlacementById(placementId);
          if (!placement) continue;
          placement.durationSeconds = recording.durationSeconds;
          placement.clipOutSeconds = placement.clipInSeconds + recording.durationSeconds;
        }

        recording.stream.getTracks().forEach((track) => track.stop());
        state.recording = { active: false, pending: false };
        setCameraStatus('ready');
        renderAll();
      }

      function stopRecording() {
        if (!state.recording.active) return;
        const { recorder } = state.recording;
        if (recorder && recorder.state !== 'inactive') {
          recorder.stop();
        }
      }

      function renderTracks() {
        dom.trackHeaders.innerHTML = '';
        dom.tracksLane.innerHTML = '';

        const trackHeaderFragment = document.createDocumentFragment();
        const trackLaneFragment = document.createDocumentFragment();

        state.tracks.forEach((track) => {
          const header = document.createElement('div');
          header.className = 'track-header';
          if (state.selectedTrackId === track.id) header.classList.add('selected');
          header.dataset.trackId = track.id;

          const nameInput = document.createElement('input');
          nameInput.className = 'track-name';
          nameInput.value = track.name;
          nameInput.dataset.trackId = track.id;

          const controls = document.createElement('div');
          controls.className = 'track-controls';

          const armBtn = document.createElement('button');
          armBtn.className = `track-btn track-arm ${track.armed ? 'armed' : ''}`;
          armBtn.textContent = track.armed ? 'ARM' : 'ARM';
          armBtn.dataset.trackId = track.id;

          const visBtn = document.createElement('button');
          visBtn.className = `track-btn track-vis ${track.visible ? '' : 'hidden'}`;
          visBtn.textContent = track.visible ? 'VIS' : 'HID';
          visBtn.dataset.trackId = track.id;

          const addBtn = document.createElement('button');
          addBtn.className = 'track-btn track-add';
          addBtn.textContent = '+';
          addBtn.dataset.trackId = track.id;

          const delBtn = document.createElement('button');
          delBtn.className = 'track-btn track-del';
          delBtn.textContent = '-';
          delBtn.dataset.trackId = track.id;

          controls.appendChild(armBtn);
          controls.appendChild(visBtn);
          controls.appendChild(addBtn);
          controls.appendChild(delBtn);

          header.appendChild(nameInput);
          header.appendChild(controls);
          trackHeaderFragment.appendChild(header);

          const row = document.createElement('div');
          row.className = 'track-row';
          if (!track.visible) row.classList.add('hidden');
          row.dataset.trackId = track.id;

          const placements = state.placements.filter((placement) => placement.trackId === track.id);
          placements.forEach((placement) => {
            const clip = getClipById(placement.clipId);
            const clipEl = document.createElement('div');
            clipEl.className = 'clip';
            if (state.selectedPlacementId === placement.id) {
              clipEl.classList.add('selected');
            }
            clipEl.dataset.placementId = placement.id;
            clipEl.style.left = `${timeToPx(placement.timelineStartSeconds)}px`;
            clipEl.style.width = `${Math.max(6, timeToPx(placement.durationSeconds))}px`;

            const label = document.createElement('div');
            label.className = 'clip-label';
            label.textContent = clip ? clip.name : 'Missing Clip';

            const leftHandle = document.createElement('div');
            leftHandle.className = 'handle left';
            const rightHandle = document.createElement('div');
            rightHandle.className = 'handle right';

            clipEl.appendChild(label);
            clipEl.appendChild(leftHandle);
            clipEl.appendChild(rightHandle);
            row.appendChild(clipEl);
          });

          trackLaneFragment.appendChild(row);
        });

        dom.trackHeaders.appendChild(trackHeaderFragment);
        dom.tracksLane.appendChild(trackLaneFragment);

        dom.tracksLane.style.height = `${state.tracks.length * TRACK_HEIGHT}px`;
        dom.timelineInner.style.height = `${RULER_HEIGHT + state.tracks.length * TRACK_HEIGHT}px`;
        renderTimelineMetrics();
      }

      function updatePlacementElement(placement) {
        const clipEl = dom.tracksLane.querySelector(`[data-placement-id="${placement.id}"]`);
        if (!clipEl) return;
        clipEl.style.left = `${timeToPx(placement.timelineStartSeconds)}px`;
        clipEl.style.width = `${Math.max(6, timeToPx(placement.durationSeconds))}px`;
      }

      function renderTimelineMetrics() {
        const duration = getTimelineDurationSeconds();
        const width = Math.max(300, timeToPx(duration));
        dom.timelineInner.style.width = `${width}px`;
        dom.ruler.width = width;
        dom.ruler.height = RULER_HEIGHT;
        dom.tracksLane.style.top = `${RULER_HEIGHT}px`;
        renderRuler(duration);
        updatePlayheadUI();
      }

      function renderRuler(duration) {
        const ctx = dom.ruler.getContext('2d');
        ctx.clearRect(0, 0, dom.ruler.width, dom.ruler.height);
        ctx.fillStyle = '#0e141b';
        ctx.fillRect(0, 0, dom.ruler.width, dom.ruler.height);

        const fps = state.settings.fps;
        const pxPerSecond = state.settings.pxPerSecond;
        const framePx = pxPerSecond / fps;
        let minorStep = 1 / fps;
        if (framePx < 6) minorStep = 5 / fps;
        if (framePx < 3) minorStep = 10 / fps;

        ctx.strokeStyle = '#2a3643';
        ctx.fillStyle = '#8fa0ad';
        ctx.font = '10px "Lucida Console", "Courier New", monospace';
        ctx.textBaseline = 'top';

        for (let t = 0; t <= duration; t += minorStep) {
          const frameIndex = Math.round(t * fps);
          const isMajor = frameIndex % fps === 0;
          const x = Math.floor(t * pxPerSecond) + 0.5;
          ctx.beginPath();
          ctx.moveTo(x, isMajor ? 0 : RULER_HEIGHT / 2);
          ctx.lineTo(x, RULER_HEIGHT);
          ctx.stroke();
          if (isMajor) {
            const label = secondsToSMPTE(t, fps);
            ctx.fillText(label, x + 4, 4);
          }
        }
      }

      function renderBin() {
        dom.binList.innerHTML = '';
        const fragment = document.createDocumentFragment();
        state.clips.forEach((clip) => {
          const item = document.createElement('div');
          item.className = 'bin-item';
          if (state.selectedClipId === clip.id) item.classList.add('selected');
          const media = state.mediaCache.get(clip.id);
          if (!media) item.classList.add('missing');
          item.dataset.clipId = clip.id;

          const title = document.createElement('div');
          title.className = 'bin-title';
          title.textContent = clip.name;

          const meta = document.createElement('div');
          meta.className = 'bin-meta';
          meta.textContent = `${clip.source} | ${clip.durationSeconds.toFixed(2)}s`;

          item.appendChild(title);
          item.appendChild(meta);
          fragment.appendChild(item);
        });

        if (state.masterAudio && state.masterAudio.name) {
          const audioItem = document.createElement('div');
          audioItem.className = 'bin-item';
          audioItem.dataset.audio = 'master';
          const title = document.createElement('div');
          title.className = 'bin-title';
          title.textContent = `Master Audio: ${state.masterAudio.name}`;
          const meta = document.createElement('div');
          meta.className = 'bin-meta';
          meta.textContent = `Start: ${secondsToSMPTE(state.masterAudio.startSeconds, state.settings.fps)}`;
          audioItem.appendChild(title);
          audioItem.appendChild(meta);
          fragment.appendChild(audioItem);
        }

        dom.binList.appendChild(fragment);
      }

      function renderInspector() {
        const fps = state.settings.fps;
        const step = 1 / fps;
        if (state.selectedPlacementId) {
          const placement = getPlacementById(state.selectedPlacementId);
          if (!placement) {
            dom.inspectorContent.textContent = 'Select a clip or placement.';
            return;
          }
          if (!placement.transform) placement.transform = defaultTransform();
          const clip = getClipById(placement.clipId);
          const track = getTrackById(placement.trackId);
          dom.inspectorContent.innerHTML = `
            <div class="field">
              <label>Clip</label>
              <div class="readonly">${clip ? clip.name : 'Missing Clip'}</div>
            </div>
            <div class="field">
              <label>Track</label>
              <div class="readonly">${track ? track.name : 'Unknown'}</div>
            </div>
            <div class="field">
              <label>Timeline Start (sec)</label>
              <input id="inspectorStart" type="number" step="${step}" value="${placement.timelineStartSeconds.toFixed(3)}" />
            </div>
            <div class="field">
              <label>Clip In (sec)</label>
              <input id="inspectorIn" type="number" step="${step}" value="${placement.clipInSeconds.toFixed(3)}" />
            </div>
            <div class="field">
              <label>Clip Out (sec)</label>
              <input id="inspectorOut" type="number" step="${step}" value="${placement.clipOutSeconds.toFixed(3)}" />
            </div>
            <div class="field">
              <label>Duration</label>
              <div class="readonly">${placement.durationSeconds.toFixed(3)}s</div>
            </div>
            <div class="field">
              <label>Start SMPTE</label>
              <div class="readonly">${secondsToSMPTE(placement.timelineStartSeconds, fps)}</div>
            </div>
            <div class="field">
              <label>Framing Scale</label>
              <input id="inspectorScale" type="number" min="0.5" max="3" step="0.05" value="${placement.transform.scale.toFixed(2)}" />
            </div>
            <div class="field">
              <label>Framing X (pan)</label>
              <input id="inspectorOffsetX" type="number" min="-1" max="1" step="0.01" value="${placement.transform.offsetX.toFixed(2)}" />
            </div>
            <div class="field">
              <label>Framing Y (pan)</label>
              <input id="inspectorOffsetY" type="number" min="-1" max="1" step="0.01" value="${placement.transform.offsetY.toFixed(2)}" />
            </div>
          `;

          const startInput = document.getElementById('inspectorStart');
          const inInput = document.getElementById('inspectorIn');
          const outInput = document.getElementById('inspectorOut');
          const scaleInput = document.getElementById('inspectorScale');
          const offsetXInput = document.getElementById('inspectorOffsetX');
          const offsetYInput = document.getElementById('inspectorOffsetY');

          startInput.addEventListener('change', () => {
            const value = parseFloat(startInput.value);
            if (!Number.isNaN(value)) {
              placement.timelineStartSeconds = Math.max(0, snapSeconds(value));
              markDirty();
              renderTracks();
              renderInspector();
            }
          });

          inInput.addEventListener('change', () => {
            const value = parseFloat(inInput.value);
            if (!Number.isNaN(value)) {
              const clipDuration = clip ? clip.durationSeconds : placement.clipOutSeconds;
              placement.clipInSeconds = clamp(snapSeconds(value), 0, Math.max(0, clipDuration - step));
              placement.durationSeconds = Math.max(step, placement.clipOutSeconds - placement.clipInSeconds);
              markDirty();
              renderTracks();
              renderInspector();
            }
          });

          outInput.addEventListener('change', () => {
            const value = parseFloat(outInput.value);
            if (!Number.isNaN(value)) {
              const clipDuration = clip ? clip.durationSeconds : value;
              placement.clipOutSeconds = clamp(snapSeconds(value), placement.clipInSeconds + step, clipDuration || value);
              placement.durationSeconds = Math.max(step, placement.clipOutSeconds - placement.clipInSeconds);
              markDirty();
              renderTracks();
              renderInspector();
            }
          });

          scaleInput.addEventListener('change', () => {
            const value = parseFloat(scaleInput.value);
            if (!Number.isNaN(value)) {
              placement.transform.scale = clamp(value, 0.5, 3);
              markDirty();
              updatePreview(true);
            }
          });

          offsetXInput.addEventListener('change', () => {
            const value = parseFloat(offsetXInput.value);
            if (!Number.isNaN(value)) {
              placement.transform.offsetX = clamp(value, -1, 1);
              markDirty();
              updatePreview(true);
            }
          });

          offsetYInput.addEventListener('change', () => {
            const value = parseFloat(offsetYInput.value);
            if (!Number.isNaN(value)) {
              placement.transform.offsetY = clamp(value, -1, 1);
              markDirty();
              updatePreview(true);
            }
          });
          return;
        }

        if (state.selectedClipId) {
          const clip = getClipById(state.selectedClipId);
          if (!clip) {
            dom.inspectorContent.textContent = 'Select a clip or placement.';
            return;
          }
          dom.inspectorContent.innerHTML = `
            <div class="field">
              <label>Clip</label>
              <div class="readonly">${clip.name}</div>
            </div>
            <div class="field">
              <label>Source</label>
              <div class="readonly">${clip.source}</div>
            </div>
            <div class="field">
              <label>Duration</label>
              <div class="readonly">${clip.durationSeconds.toFixed(2)}s</div>
            </div>
          `;
          return;
        }

        dom.inspectorContent.textContent = 'Select a clip or placement.';
      }

      function renderAll() {
        renderTracks();
        renderBin();
        renderInspector();
        updateExportNotes();
      }

      function updatePreview(force = false) {
        const now = performance.now();
        if (!force && now - state.preview.lastUpdate < 120) return;
        state.preview.lastUpdate = now;

        const placement = getVisiblePlacementAtTime(state.transport.playheadSeconds);
        if (!placement) {
          dom.programVideo.style.display = 'none';
          dom.programVideo.style.transform = 'translate(0%, 0%) scale(1)';
          dom.monitorPlaceholder.style.display = 'block';
          state.preview.activeClipId = null;
          return;
        }

        const clip = getClipById(placement.clipId);
        if (!clip) {
          dom.programVideo.style.display = 'none';
          dom.monitorPlaceholder.style.display = 'block';
          return;
        }

        const media = state.mediaCache.get(clip.id);
        if (!media || !media.url) {
          dom.programVideo.style.display = 'none';
          dom.monitorPlaceholder.style.display = 'block';
          return;
        }

        const targetTime = Math.max(0, (state.transport.playheadSeconds - placement.timelineStartSeconds) + placement.clipInSeconds);
        const transform = placement.transform || defaultTransform();

        if (state.preview.activeClipId !== clip.id) {
          dom.programVideo.src = media.url;
          dom.programVideo.load();
          state.preview.activeClipId = clip.id;
        }

        if (dom.programVideo.readyState >= 2) {
          dom.programVideo.currentTime = Math.min(targetTime, dom.programVideo.duration || targetTime);
        } else {
          dom.programVideo.onloadedmetadata = () => {
            dom.programVideo.currentTime = Math.min(targetTime, dom.programVideo.duration || targetTime);
          };
        }

        dom.programVideo.pause();
        dom.programVideo.style.transform = `translate(${transform.offsetX * 50}%, ${transform.offsetY * 50}%) scale(${transform.scale})`;
        dom.programVideo.style.transformOrigin = 'center';
        dom.programVideo.style.display = 'block';
        dom.monitorPlaceholder.style.display = 'none';
      }

      function updateExportNotes() {
        const hasAudio = state.masterAudio && state.masterAudio.name;
        const offset = state.masterAudio ? state.masterAudio.startSeconds : 0;
        const audioName = state.masterAudio ? state.masterAudio.name : 'master-audio.wav';
        const offsetText = offset >= 0 ? offset.toFixed(3) : `-${Math.abs(offset).toFixed(3)}`;
        const lines = [];
        lines.push('Preview render is video-only (topmost visible clip).');
        lines.push('To mux master audio with ffmpeg:');
        lines.push(`ffmpeg -i camorder-preview.webm -itsoffset ${offsetText} -i "${audioName}" -c:v copy -c:a aac -shortest camorder-final.mp4`);
        if (!hasAudio) {
          lines.push('Import master audio to get a correct offset.');
        }
        dom.exportNotes.textContent = lines.join('\n');
      }

      function setMidiStatus(status, label = '') {
        let text = label || 'MIDI Off';
        let cls = 'status-pill off';
        if (status === 'ready') {
          text = label || 'MIDI Ready';
          cls = 'status-pill';
        } else if (status === 'connected') {
          text = label || 'MIDI Connected';
          cls = 'status-pill';
        } else if (status === 'warn') {
          text = label || 'MIDI Warning';
          cls = 'status-pill warn';
        }
        dom.midiStatus.textContent = text;
        dom.midiStatus.className = cls;
      }

      function pickPreferredMidiInput(inputs) {
        if (!inputs.length) return '';
        const priority = [/logic/i, /iac/i, /virtual/i, /bus/i];
        for (const pattern of priority) {
          const match = inputs.find((input) => pattern.test(input.name || ''));
          if (match) return match.id;
        }
        return inputs[0].id;
      }

      function refreshMidiInputs() {
        if (!state.midi.access) return;
        const inputs = Array.from(state.midi.access.inputs.values());
        const currentSelection = dom.midiInputSelect.value;
        dom.midiInputSelect.innerHTML = '';
        if (!inputs.length) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'No MIDI inputs';
          dom.midiInputSelect.appendChild(opt);
          return;
        }
        inputs.forEach((input) => {
          const opt = document.createElement('option');
          opt.value = input.id;
          opt.textContent = input.name || input.id;
          dom.midiInputSelect.appendChild(opt);
        });
        if (currentSelection && inputs.some((input) => input.id === currentSelection)) {
          dom.midiInputSelect.value = currentSelection;
        } else {
          dom.midiInputSelect.value = pickPreferredMidiInput(inputs);
        }
      }

      async function requestMidiAccess() {
        if (!navigator.requestMIDIAccess) {
          setMidiStatus('warn', 'MIDI Unsupported');
          return null;
        }
        try {
          const access = await navigator.requestMIDIAccess({ sysex: true });
          return access;
        } catch (error) {
          console.warn('MIDI access error', error);
          setMidiStatus('warn', 'MIDI Blocked');
          return null;
        }
      }

      function disconnectMidi() {
        if (state.midi.input) {
          state.midi.input.onmidimessage = null;
        }
        state.midi.input = null;
        state.midi.connected = false;
        state.midi.clock.playing = false;
        state.midi.mtc.active = false;
        dom.midiConnectBtn.textContent = 'Enable MIDI';
        setMidiStatus('ready', 'MIDI Ready');
        updateExternalMode();
      }

      async function connectMidi() {
        if (state.midi.connected) {
          disconnectMidi();
          return;
        }
        if (!state.midi.access) {
          state.midi.access = await requestMidiAccess();
          if (!state.midi.access) return;
          state.midi.access.onstatechange = refreshMidiInputs;
        }
        refreshMidiInputs();
        const inputId = dom.midiInputSelect.value;
        const input = Array.from(state.midi.access.inputs.values()).find((item) => item.id === inputId);
        if (!input) {
          setMidiStatus('warn', 'No MIDI Input');
          return;
        }
        state.midi.input = input;
        state.midi.input.onmidimessage = handleMidiMessage;
        state.midi.connected = true;
        state.midi.clock.lastTick = 0;
        state.midi.clock.playing = false;
        state.midi.mtc.active = false;
        dom.midiConnectBtn.textContent = 'Disable MIDI';
        setMidiStatus('connected', input.name || 'MIDI Connected');
        updateExternalMode();
      }

      function handleMidiClockTick(timeStamp) {
        if (state.midi.mode !== 'clock') return;
        const lastTick = state.midi.clock.lastTick;
        if (lastTick) {
          const delta = Math.max(0.001, (timeStamp - lastTick) / 1000);
          const bpm = 60 / (delta * 24);
          if (Number.isFinite(bpm) && bpm >= 20 && bpm <= 300) {
            state.midi.clock.bpm = state.midi.clock.bpm * 0.85 + bpm * 0.15;
          }
        }
        state.midi.clock.lastTick = timeStamp;
        if (!state.midi.clock.playing) return;
        const tickSeconds = 60 / (state.midi.clock.bpm * 24);
        setPlayhead(state.transport.playheadSeconds + tickSeconds);
        updateRecordingPlacements();
        if (state.tracks.some((track) => track.armed)) {
          if (state.transport.state !== 'record' && !state.recording.pending) {
            startExternalRecord();
          }
        }
      }

      function handleMtcQuarterFrame(data) {
        if (state.midi.mode !== 'mtc') return;
        const msgType = (data >> 4) & 0x07;
        const value = data & 0x0f;
        state.midi.mtc.qf[msgType] = value;
        const frames = state.midi.mtc.qf[0] | ((state.midi.mtc.qf[1] & 0x1) << 4);
        const seconds = state.midi.mtc.qf[2] | ((state.midi.mtc.qf[3] & 0x3) << 4);
        const minutes = state.midi.mtc.qf[4] | ((state.midi.mtc.qf[5] & 0x3) << 4);
        const hours = state.midi.mtc.qf[6] | ((state.midi.mtc.qf[7] & 0x1) << 4);
        const rateCode = (state.midi.mtc.qf[7] >> 1) & 0x3;
        const fps = rateCode === 0 ? 24 : rateCode === 1 ? 25 : rateCode === 2 ? 30 : 30;
        if (fps !== state.settings.fps) {
          state.settings.fps = fps;
          dom.fpsSelect.value = String(fps);
          renderTimelineMetrics();
        }
        const timeSeconds = hours * 3600 + minutes * 60 + seconds + frames / fps;
        setPlayhead(timeSeconds);
        if (state.transport.state !== 'record') setTransportState('play');
        state.midi.mtc.lastUpdate = performance.now();
        state.midi.mtc.active = true;
        updateRecordingPlacements();
      }

      function handleMtcFullFrame(data) {
        if (state.midi.mode !== 'mtc') return;
        if (data.length < 9) return;
        const rateCode = (data[5] >> 5) & 0x3;
        const fps = rateCode === 0 ? 24 : rateCode === 1 ? 25 : rateCode === 2 ? 30 : 30;
        const hours = data[5] & 0x1f;
        const minutes = data[6];
        const seconds = data[7];
        const frames = data[8];
        if (fps !== state.settings.fps) {
          state.settings.fps = fps;
          dom.fpsSelect.value = String(fps);
          renderTimelineMetrics();
        }
        const timeSeconds = hours * 3600 + minutes * 60 + seconds + frames / fps;
        setPlayhead(timeSeconds);
        if (state.transport.state !== 'record') setTransportState('play');
        state.midi.mtc.lastUpdate = performance.now();
        state.midi.mtc.active = true;
        updateRecordingPlacements();
      }

      function handleMmcCommand(cmd) {
        const mode = state.midi.mode;
        if (cmd === 0x02) {
          if (mode === 'clock') state.midi.clock.playing = true;
          setTransportState('play');
        } else if (cmd === 0x01) {
          if (mode === 'clock') state.midi.clock.playing = false;
          stopTransport();
        } else if (cmd === 0x06) {
          if (mode === 'clock') state.midi.clock.playing = true;
          startExternalRecord();
        } else if (cmd === 0x07) {
          if (mode === 'clock') state.midi.clock.playing = false;
          stopTransport();
        }
      }

      function handleSongPositionPointer(lsb, msb) {
        if (state.midi.mode !== 'clock') return;
        const spp = (msb << 7) | lsb;
        const bpm = Math.max(20, state.midi.clock.bpm || 120);
        const seconds = (spp * 60) / (bpm * 4);
        setPlayhead(seconds);
      }

      function handleMmcLocate(data) {
        if (state.midi.mode !== 'mmc') return;
        if (data.length < 12) return;
        if (data[1] !== 0x7F || data[3] !== 0x06 || data[4] !== 0x44) return;
        const fpsCode = (data[5] >> 5) & 0x03;
        const fps = fpsCode === 0 ? 24 : fpsCode === 1 ? 25 : fpsCode === 2 ? 30 : 30;
        const hours = data[5] & 0x1f;
        const minutes = data[6];
        const seconds = data[7];
        const frames = data[8];
        if (fps !== state.settings.fps) {
          state.settings.fps = fps;
          dom.fpsSelect.value = String(fps);
          renderTimelineMetrics();
        }
        const timeSeconds = hours * 3600 + minutes * 60 + seconds + frames / fps;
        setPlayhead(timeSeconds);
      }

      function handleMidiMessage(event) {
        const data = event.data;
        const status = data[0];
        if (status === 0xF8) {
          handleMidiClockTick(event.timeStamp);
          return;
        }
        if (status === 0xFA) {
          if (state.midi.mode === 'clock') {
            state.midi.clock.playing = true;
            setPlayhead(0);
            setTransportState('play');
          }
          return;
        }
        if (status === 0xFB) {
          if (state.midi.mode === 'clock') {
            state.midi.clock.playing = true;
            setTransportState('play');
          }
          return;
        }
        if (status === 0xFC) {
          if (state.midi.mode === 'clock') {
            state.midi.clock.playing = false;
          }
          stopTransport();
          return;
        }
        if (status === 0xF1 && data.length > 1) {
          handleMtcQuarterFrame(data[1]);
          return;
        }
        if (status === 0xF2 && data.length > 2) {
          handleSongPositionPointer(data[1], data[2]);
          return;
        }
        if (status === 0xF0) {
          if (data[1] === 0x7F && data[3] === 0x01 && data[4] === 0x01) {
            handleMtcFullFrame(data);
            return;
          }
          if (data[1] === 0x7F && data[3] === 0x06 && data.length > 4) {
            if (data[4] === 0x44) {
              handleMmcLocate(data);
              return;
            }
            handleMmcCommand(data[4]);
          }
        }
      }

      async function startExternalRecord() {
        if (state.transport.state === 'record') return;
        const ok = await startRecording();
        if (ok) setTransportState('record');
      }

      function setupTimelineScrollSync() {
        let syncing = false;
        dom.trackHeaders.addEventListener('scroll', () => {
          if (syncing) return;
          syncing = true;
          dom.timelineScroll.scrollTop = dom.trackHeaders.scrollTop;
          syncing = false;
        });
        dom.timelineScroll.addEventListener('scroll', () => {
          if (syncing) return;
          syncing = true;
          dom.trackHeaders.scrollTop = dom.timelineScroll.scrollTop;
          syncing = false;
        });
      }

      function setupTrackHeaderEvents() {
        dom.trackHeaders.addEventListener('click', (event) => {
          const header = event.target.closest('.track-header');
          if (!header) return;
          const trackId = header.dataset.trackId;
          if (!trackId) return;

          if (event.target.classList.contains('track-arm')) {
            const track = getTrackById(trackId);
            if (track) {
              track.armed = !track.armed;
              markDirty();
              renderTracks();
            }
            return;
          }

          if (event.target.classList.contains('track-vis')) {
            const track = getTrackById(trackId);
            if (track) {
              track.visible = !track.visible;
              markDirty();
              renderTracks();
              updatePreview(true);
            }
            return;
          }

          if (event.target.classList.contains('track-add')) {
            addTrack(trackId);
            return;
          }

          if (event.target.classList.contains('track-del')) {
            deleteTrack(trackId);
            return;
          }

          selectTrack(trackId);
        });

        dom.trackHeaders.addEventListener('input', (event) => {
          if (!event.target.classList.contains('track-name')) return;
          const track = getTrackById(event.target.dataset.trackId);
          if (track) {
            track.name = event.target.value;
            markDirty();
          }
        });
      }

      let dragState = null;
      let monitorDrag = null;

      function setupTimelineInteractions() {
        dom.tracksLane.addEventListener('pointerdown', (event) => {
          const clipEl = event.target.closest('.clip');
          if (!clipEl) return;
          const placementId = clipEl.dataset.placementId;
          if (!placementId) return;
          selectPlacement(placementId);

          let mode = 'move';
          if (event.target.classList.contains('handle')) {
            mode = event.target.classList.contains('left') ? 'trim-left' : 'trim-right';
          }

          const placement = getPlacementById(placementId);
          const clip = placement ? getClipById(placement.clipId) : null;
          if (!placement) return;

          dragState = {
            mode,
            placementId,
            startX: event.clientX,
            originStart: placement.timelineStartSeconds,
            originIn: placement.clipInSeconds,
            originOut: placement.clipOutSeconds,
            clipDuration: clip ? clip.durationSeconds : placement.clipOutSeconds,
          };

          clipEl.setPointerCapture(event.pointerId);
        });

        dom.timelineScroll.addEventListener('pointerdown', (event) => {
          if (event.target.closest('.clip')) return;
          const rect = dom.timelineInner.getBoundingClientRect();
          const x = event.clientX - rect.left + dom.timelineScroll.scrollLeft;
          setPlayhead(pxToTime(x));

          dragState = {
            mode: 'playhead',
            startX: event.clientX,
            originPlayhead: state.transport.playheadSeconds,
          };
        });

        dom.playhead.addEventListener('pointerdown', (event) => {
          dragState = {
            mode: 'playhead',
            startX: event.clientX,
            originPlayhead: state.transport.playheadSeconds,
          };
          dom.playhead.setPointerCapture(event.pointerId);
        });

        window.addEventListener('pointermove', (event) => {
          if (!dragState) return;
          const dx = event.clientX - dragState.startX;
          const deltaSeconds = snapSeconds(pxToTime(dx));

          if (dragState.mode === 'playhead') {
            setPlayhead(dragState.originPlayhead + deltaSeconds);
            updatePreview(true);
            return;
          }

          const placement = getPlacementById(dragState.placementId);
          if (!placement) return;
          const frame = 1 / state.settings.fps;

          if (dragState.mode === 'move') {
            placement.timelineStartSeconds = Math.max(0, snapSeconds(dragState.originStart + deltaSeconds));
            updatePlacementElement(placement);
            return;
          }

          if (dragState.mode === 'trim-left') {
            const clipDuration = dragState.clipDuration || placement.clipOutSeconds;
            const newClipIn = clamp(snapSeconds(dragState.originIn + deltaSeconds), 0, dragState.originOut - frame);
            const offset = newClipIn - dragState.originIn;
            const newStart = Math.max(0, dragState.originStart + offset);
            placement.clipInSeconds = newClipIn;
            placement.timelineStartSeconds = newStart;
            placement.durationSeconds = Math.max(frame, placement.clipOutSeconds - placement.clipInSeconds);
            updatePlacementElement(placement);
            return;
          }

          if (dragState.mode === 'trim-right') {
            const clipDuration = dragState.clipDuration || dragState.originOut + deltaSeconds;
            const newOut = clamp(snapSeconds(dragState.originOut + deltaSeconds), dragState.originIn + frame, clipDuration || dragState.originOut + deltaSeconds);
            placement.clipOutSeconds = newOut;
            placement.durationSeconds = Math.max(frame, placement.clipOutSeconds - placement.clipInSeconds);
            updatePlacementElement(placement);
          }
        });

        window.addEventListener('pointerup', () => {
          if (dragState) {
            markDirty();
            renderTracks();
            renderInspector();
          }
          dragState = null;
        });

        dom.tracksLane.addEventListener('click', (event) => {
          if (event.target.closest('.clip')) return;
          state.selectedPlacementId = null;
          renderTracks();
          renderInspector();
        });

        dom.ruler.addEventListener('wheel', (event) => {
          event.preventDefault();
          const delta = -event.deltaY * 0.2;
          setZoom(state.settings.pxPerSecond + delta, event.offsetX);
        }, { passive: false });

        dom.timelineScroll.addEventListener('wheel', (event) => {
          if (!(event.ctrlKey || event.metaKey)) return;
          event.preventDefault();
          const rect = dom.timelineScroll.getBoundingClientRect();
          const anchor = event.clientX - rect.left;
          const delta = -event.deltaY * 0.2;
          setZoom(state.settings.pxPerSecond + delta, anchor);
        }, { passive: false });
      }

      function setupMonitorInteractions() {
        dom.monitorFrame.addEventListener('pointerdown', (event) => {
          if (!state.selectedPlacementId) return;
          const placement = getPlacementById(state.selectedPlacementId);
          if (!placement) return;
          if (!placement.transform) placement.transform = defaultTransform();
          monitorDrag = {
            placementId: placement.id,
            startX: event.clientX,
            startY: event.clientY,
            baseOffsetX: placement.transform.offsetX,
            baseOffsetY: placement.transform.offsetY,
            width: dom.monitorFrame.clientWidth || 1,
            height: dom.monitorFrame.clientHeight || 1,
          };
          dom.monitorFrame.setPointerCapture(event.pointerId);
        });

        window.addEventListener('pointermove', (event) => {
          if (!monitorDrag) return;
          const placement = getPlacementById(monitorDrag.placementId);
          if (!placement) return;
          const dx = event.clientX - monitorDrag.startX;
          const dy = event.clientY - monitorDrag.startY;
          const nextX = monitorDrag.baseOffsetX + dx / (monitorDrag.width * 0.5);
          const nextY = monitorDrag.baseOffsetY + dy / (monitorDrag.height * 0.5);
          placement.transform.offsetX = clamp(nextX, -1, 1);
          placement.transform.offsetY = clamp(nextY, -1, 1);
          updatePreview(true);
        });

        window.addEventListener('pointerup', () => {
          if (!monitorDrag) return;
          markDirty();
          renderInspector();
          monitorDrag = null;
        });
      }

      function splitSelectedPlacement() {
        if (!state.selectedPlacementId) return;
        const placement = getPlacementById(state.selectedPlacementId);
        if (!placement) return;
        const splitTime = state.transport.playheadSeconds;
        const start = placement.timelineStartSeconds;
        const end = start + placement.durationSeconds;
        if (splitTime <= start || splitTime >= end) return;

        const offset = splitTime - start;
        const leftDuration = offset;
        const rightDuration = placement.durationSeconds - offset;

        const newPlacement = {
          id: makeId('plc'),
          clipId: placement.clipId,
          trackId: placement.trackId,
          timelineStartSeconds: splitTime,
          clipInSeconds: placement.clipInSeconds + offset,
          clipOutSeconds: placement.clipOutSeconds,
          durationSeconds: rightDuration,
          transform: { ...placement.transform },
        };

        placement.clipOutSeconds = placement.clipInSeconds + leftDuration;
        placement.durationSeconds = leftDuration;

        state.placements.push(newPlacement);
        markDirty();
        renderAll();
      }

      function deleteSelectedPlacement() {
        if (!state.selectedPlacementId) return;
        state.placements = state.placements.filter((placement) => placement.id !== state.selectedPlacementId);
        state.selectedPlacementId = null;
        markDirty();
        renderAll();
      }

      function setupBinEvents() {
        dom.binList.addEventListener('click', (event) => {
          const item = event.target.closest('.bin-item');
          if (!item) return;
          if (item.dataset.clipId) {
            selectClip(item.dataset.clipId);
          }
        });
      }

      function insertSelectedClipToTrack() {
        if (!state.selectedClipId || !state.selectedTrackId) return;
        const clip = getClipById(state.selectedClipId);
        if (!clip) return;
        const duration = clip.durationSeconds || 5;
        const placement = {
          id: makeId('plc'),
          clipId: clip.id,
          trackId: state.selectedTrackId,
          timelineStartSeconds: state.transport.playheadSeconds,
          clipInSeconds: 0,
          clipOutSeconds: duration,
          durationSeconds: duration,
          transform: defaultTransform(),
        };
        state.placements.push(placement);
        markDirty();
        renderAll();
      }

      function setupKeyboardShortcuts() {
        document.addEventListener('keydown', (event) => {
          const tag = event.target.tagName;
          if (tag === 'INPUT' || tag === 'TEXTAREA') return;
          if (!isManualMode()) return;
          if (event.code === 'Space') {
            event.preventDefault();
            startManualPlay();
          }
          if (event.key.toLowerCase() === 'r') {
            event.preventDefault();
            startManualRecord();
          }
          if (event.key.toLowerCase() === 's') {
            event.preventDefault();
            splitSelectedPlacement();
          }
          if (event.key === 'Delete') {
            event.preventDefault();
            deleteSelectedPlacement();
          }
        });
      }

      function buildProjectJSON() {
        return {
          settings: {
            fps: state.settings.fps,
            pxPerSecond: state.settings.pxPerSecond,
            createdAt: state.settings.createdAt,
          },
          tracks: state.tracks.map((track) => ({
            id: track.id,
            name: track.name,
            armed: track.armed,
            visible: track.visible,
            order: track.order,
          })),
          clips: state.clips.map((clip) => ({
            id: clip.id,
            name: clip.name,
            createdAt: clip.createdAt,
            durationSeconds: clip.durationSeconds,
            source: clip.source,
            filename: clip.filename,
          })),
          placements: state.placements.map((placement) => ({
            id: placement.id,
            clipId: placement.clipId,
            trackId: placement.trackId,
            timelineStartSeconds: placement.timelineStartSeconds,
            clipInSeconds: placement.clipInSeconds,
            clipOutSeconds: placement.clipOutSeconds,
            durationSeconds: placement.durationSeconds,
            transform: placement.transform || defaultTransform(),
          })),
          masterAudio: state.masterAudio && state.masterAudio.name ? {
            name: state.masterAudio.name,
            startSeconds: state.masterAudio.startSeconds,
            filename: state.masterAudio.filename,
          } : null,
        };
      }

      async function ensurePermission(handle) {
        if (!handle) return false;
        if (await handle.queryPermission({ mode: 'readwrite' }) === 'granted') return true;
        return (await handle.requestPermission({ mode: 'readwrite' })) === 'granted';
      }

      async function chooseProjectFolder() {
        if (!window.showDirectoryPicker) {
          alert('File System Access API not available.');
          return;
        }
        state.projectHandle = await window.showDirectoryPicker();
        const ok = await ensurePermission(state.projectHandle);
        if (!ok) alert('Write permission denied for the selected folder.');
      }

      async function saveProject() {
        if (!window.showDirectoryPicker) {
          alert('File System Access API not available.');
          return;
        }
        if (!state.projectHandle) {
          await chooseProjectFolder();
        }
        if (!state.projectHandle) return;
        const ok = await ensurePermission(state.projectHandle);
        if (!ok) return;

        const mediaDir = await state.projectHandle.getDirectoryHandle('media', { create: true });
        const audioDir = await state.projectHandle.getDirectoryHandle('audio', { create: true });

        for (const clip of state.clips) {
          const media = state.mediaCache.get(clip.id);
          if (!media) continue;
          const filename = clip.filename || `${clip.id}.webm`;
          clip.filename = filename;
          if (media.blob) {
            const handle = await mediaDir.getFileHandle(filename, { create: true });
            const writable = await handle.createWritable();
            await writable.write(media.blob);
            await writable.close();
          } else if (media.file) {
            const handle = await mediaDir.getFileHandle(filename, { create: true });
            const writable = await handle.createWritable();
            await writable.write(media.file);
            await writable.close();
          }
        }

        if (state.masterAudio && state.masterAudio.file) {
          const audioHandle = await audioDir.getFileHandle(state.masterAudio.filename || state.masterAudio.name, { create: true });
          const writable = await audioHandle.createWritable();
          await writable.write(state.masterAudio.file);
          await writable.close();
        }

        const projectData = buildProjectJSON();
        const projectHandle = await state.projectHandle.getFileHandle('camorder-project.json', { create: true });
        const writable = await projectHandle.createWritable();
        await writable.write(JSON.stringify(projectData, null, 2));
        await writable.close();

        state.dirty = false;
        alert('Project saved.');
      }

      function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
      }

      function downloadProjectJSON() {
        const data = buildProjectJSON();
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        downloadBlob(blob, 'camorder-project.json');
      }

      function downloadRecordedClips() {
        for (const clip of state.clips) {
          if (clip.source !== 'recorded') continue;
          const media = state.mediaCache.get(clip.id);
          if (media && media.blob) {
            downloadBlob(media.blob, clip.filename || `${clip.id}.webm`);
          }
        }
      }

      function loadProjectFromJSON(data) {
        if (!data) return;
        state.settings.fps = data.settings?.fps || state.settings.fps;
        state.settings.pxPerSecond = data.settings?.pxPerSecond || state.settings.pxPerSecond;
        dom.fpsSelect.value = String(state.settings.fps);
        dom.zoomSlider.value = String(state.settings.pxPerSecond);
        setZoom(state.settings.pxPerSecond);

        state.tracks = (data.tracks || []).map((track) => ({
          id: track.id,
          name: track.name,
          armed: !!track.armed,
          visible: track.visible !== false,
          order: track.order || 0,
        }));
        updateTrackOrder();

        state.clips = (data.clips || []).map((clip) => ({
          id: clip.id,
          name: clip.name,
          createdAt: clip.createdAt,
          durationSeconds: clip.durationSeconds || 0,
          source: clip.source || 'imported',
          filename: clip.filename,
        }));

        state.placements = (data.placements || []).map((placement) => ({
          id: placement.id,
          clipId: placement.clipId,
          trackId: placement.trackId,
          timelineStartSeconds: placement.timelineStartSeconds || 0,
          clipInSeconds: placement.clipInSeconds || 0,
          clipOutSeconds: placement.clipOutSeconds || 0,
          durationSeconds: placement.durationSeconds || 0,
          transform: placement.transform ? {
            scale: placement.transform.scale || 1,
            offsetX: placement.transform.offsetX || 0,
            offsetY: placement.transform.offsetY || 0,
          } : defaultTransform(),
        }));

        state.masterAudio = data.masterAudio ? {
          file: null,
          name: data.masterAudio.name || '',
          startSeconds: data.masterAudio.startSeconds || 0,
          filename: data.masterAudio.filename || data.masterAudio.name || '',
        } : { file: null, name: '', startSeconds: 0, filename: '' };

        state.mediaCache.clear();
        state.videoCache.clear();
        state.selectedClipId = null;
        state.selectedPlacementId = null;
        state.selectedTrackId = null;
        state.dirty = false;
        renderAll();
      }

      async function loadProjectFromFile(file) {
        const text = await file.text();
        const data = JSON.parse(text);
        loadProjectFromJSON(data);
      }

      async function relinkMedia(files) {
        if (!files || !files.length) return;
        for (const file of files) {
          const clip = state.clips.find((item) => item.filename === file.name || item.name === file.name);
          if (clip) {
            const url = URL.createObjectURL(file);
            state.mediaCache.set(clip.id, {
              file,
              url,
              name: clip.name,
              filename: file.name,
              source: clip.source,
            });
            await setClipDurationFromFile(clip, url);
            continue;
          }
          if (state.masterAudio && file.name === state.masterAudio.name) {
            state.masterAudio.file = file;
            state.masterAudio.filename = file.name;
          }
        }
        renderAll();
      }

      async function setClipDurationFromFile(clip, url) {
        return new Promise((resolve) => {
          const tempVideo = document.createElement('video');
          tempVideo.preload = 'metadata';
          tempVideo.src = url;
          tempVideo.onloadedmetadata = () => {
            clip.durationSeconds = tempVideo.duration || clip.durationSeconds;
            resolve();
          };
          tempVideo.onerror = () => resolve();
        });
      }

      async function importVideoFile(file) {
        const clipId = makeId('clip');
        const url = URL.createObjectURL(file);
        const clip = {
          id: clipId,
          name: file.name,
          createdAt: new Date().toISOString(),
          durationSeconds: 0,
          source: 'imported',
          filename: file.name,
        };
        state.clips.push(clip);
        state.mediaCache.set(clipId, {
          file,
          url,
          name: clip.name,
          filename: file.name,
          source: 'imported',
        });
        await setClipDurationFromFile(clip, url);
        markDirty();
        renderAll();
      }

      function importAudioFile(file) {
        state.masterAudio = {
          file,
          name: file.name,
          startSeconds: state.transport.playheadSeconds,
          filename: file.name,
        };
        markDirty();
        renderBin();
        updateExportNotes();
      }

      async function renderPreview() {
        if (dom.renderPreviewBtn.disabled) return;
        const duration = getTimelineDurationSeconds();
        if (duration <= 0) {
          alert('Nothing to render.');
          return;
        }
        dom.renderPreviewBtn.disabled = true;
        dom.renderPreviewBtn.textContent = 'Rendering...';

        const fps = state.settings.fps;
        const canvas = document.createElement('canvas');
        const width = 1280;
        const height = 720;
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);

        const stream = canvas.captureStream(fps);
        const mimeType = getSupportedMimeType() || 'video/webm';
        const recorder = new MediaRecorder(stream, { mimeType });
        const chunks = [];

        recorder.ondataavailable = (event) => {
          if (event.data.size > 0) chunks.push(event.data);
        };

        recorder.start();

        const frameDuration = 1 / fps;

        for (let t = 0; t <= duration; t += frameDuration) {
          const placement = getVisiblePlacementAtTime(t);
          if (!placement) {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
          } else {
            const clip = getClipById(placement.clipId);
            const media = clip ? state.mediaCache.get(clip.id) : null;
            if (!clip || !media || !media.url) {
              ctx.fillStyle = '#000';
              ctx.fillRect(0, 0, width, height);
            } else {
              const videoEl = await getVideoElementForRender(clip.id, media.url);
              const seekTime = Math.max(0, (t - placement.timelineStartSeconds) + placement.clipInSeconds);
              const transform = placement.transform || defaultTransform();
              const scale = clamp(transform.scale || 1, 0.5, 3);
              const offsetX = clamp(transform.offsetX || 0, -1, 1);
              const offsetY = clamp(transform.offsetY || 0, -1, 1);
              await seekVideo(videoEl, seekTime);
              const destW = width * scale;
              const destH = height * scale;
              const destX = (width - destW) / 2 + offsetX * (width * 0.5);
              const destY = (height - destH) / 2 + offsetY * (height * 0.5);
              ctx.drawImage(videoEl, destX, destY, destW, destH);
            }
          }
          await new Promise((resolve) => setTimeout(resolve, 1000 / fps));
        }

        await new Promise((resolve) => {
          recorder.onstop = resolve;
          recorder.stop();
        });

        const blob = new Blob(chunks, { type: mimeType });
        downloadBlob(blob, 'camorder-preview.webm');
        dom.renderPreviewBtn.disabled = false;
        dom.renderPreviewBtn.textContent = 'Render Preview WebM';
      }

      async function getVideoElementForRender(clipId, url) {
        if (state.videoCache.has(clipId)) return state.videoCache.get(clipId);
        const video = document.createElement('video');
        video.src = url;
        video.muted = true;
        video.playsInline = true;
        await new Promise((resolve) => {
          video.onloadedmetadata = resolve;
          video.onerror = resolve;
        });
        state.videoCache.set(clipId, video);
        return video;
      }

      function seekVideo(video, time) {
        return new Promise((resolve) => {
          if (!video || Number.isNaN(time)) {
            resolve();
            return;
          }
          const handler = () => {
            video.removeEventListener('seeked', handler);
            resolve();
          };
          video.addEventListener('seeked', handler);
          video.currentTime = Math.min(time, video.duration || time);
        });
      }

      function updateFsUi() {
        const supported = 'showDirectoryPicker' in window;
        dom.chooseFolderBtn.disabled = !supported;
        dom.saveProjectBtn.disabled = !supported;
      }

      function setupEvents() {
        dom.playBtn.addEventListener('click', startManualPlay);
        dom.stopBtn.addEventListener('click', stopTransport);
        dom.recordBtn.addEventListener('click', startManualRecord);
        dom.fpsSelect.addEventListener('change', () => {
          state.settings.fps = parseInt(dom.fpsSelect.value, 10);
          renderTimelineMetrics();
          renderInspector();
          updateExportNotes();
        });
        dom.zoomSlider.addEventListener('input', () => {
          setZoom(parseInt(dom.zoomSlider.value, 10));
        });
        dom.refreshDevices.addEventListener('click', refreshDevices);
        dom.enableCameraBtn.addEventListener('click', warmUpCamera);
        dom.cameraSelect.addEventListener('change', () => {
          setCameraStatus('off');
          updateCameraSourceUI();
        });
        dom.resolutionSelect.addEventListener('change', () => setCameraStatus('off'));
        dom.midiConnectBtn.addEventListener('click', connectMidi);
        dom.midiModeSelect.addEventListener('change', () => {
          state.midi.mode = dom.midiModeSelect.value;
          state.midi.mtc.active = false;
          state.midi.clock.playing = false;
          updateExternalMode();
        });
        dom.midiInputSelect.addEventListener('change', () => {
          if (state.midi.connected) {
            disconnectMidi();
            connectMidi();
          }
        });

        dom.addTrackBtn.addEventListener('click', () => addTrack());
        dom.splitBtn.addEventListener('click', splitSelectedPlacement);
        dom.deletePlacementBtn.addEventListener('click', deleteSelectedPlacement);
        dom.insertToTrackBtn.addEventListener('click', insertSelectedClipToTrack);

        dom.importVideoBtn.addEventListener('click', () => dom.importVideoInput.click());
        dom.importAudioBtn.addEventListener('click', () => dom.importAudioInput.click());
        dom.importVideoInput.addEventListener('change', async (event) => {
          const file = event.target.files[0];
          if (file) await importVideoFile(file);
          dom.importVideoInput.value = '';
        });
        dom.importAudioInput.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (file) importAudioFile(file);
          dom.importAudioInput.value = '';
        });

        dom.chooseFolderBtn.addEventListener('click', chooseProjectFolder);
        dom.saveProjectBtn.addEventListener('click', saveProject);
        dom.loadProjectBtn.addEventListener('click', () => dom.loadProjectInput.click());
        dom.loadProjectInput.addEventListener('change', async (event) => {
          const file = event.target.files[0];
          if (file) await loadProjectFromFile(file);
          dom.loadProjectInput.value = '';
        });
        dom.relinkBtn.addEventListener('click', () => dom.relinkInput.click());
        dom.relinkInput.addEventListener('change', async (event) => {
          const files = Array.from(event.target.files || []);
          await relinkMedia(files);
          dom.relinkInput.value = '';
        });

        dom.downloadProjectBtn.addEventListener('click', downloadProjectJSON);
        dom.downloadClipsBtn.addEventListener('click', downloadRecordedClips);
        dom.exportEdlBtn.addEventListener('click', downloadProjectJSON);
        dom.renderPreviewBtn.addEventListener('click', renderPreview);

        setupTrackHeaderEvents();
        setupTimelineScrollSync();
        setupTimelineInteractions();
        setupMonitorInteractions();
        setupBinEvents();
        setupKeyboardShortcuts();
        setupPanelCollapseEvents();

        window.addEventListener('resize', () => {
          renderTimelineMetrics();
          updatePanelLayout();
        });

        window.addEventListener('beforeunload', (event) => {
          if (!state.dirty) return;
          event.preventDefault();
          event.returnValue = '';
        });
      }

      function tick() {
        const now = performance.now();
        const midiTimingActive = state.midi.connected && (
          (state.midi.mode === 'clock' && state.midi.clock.playing) ||
          (state.midi.mode === 'mtc' && state.midi.mtc.active)
        );

        if (state.midi.connected && state.midi.mode === 'mtc' && state.midi.mtc.active) {
          if (now - state.midi.mtc.lastUpdate > 500) {
            state.midi.mtc.active = false;
            stopTransport();
          }
        }

        if ((state.transport.state === 'play' || state.transport.state === 'record') && !midiTimingActive) {
          const elapsed = (performance.now() - state.transport.baseRealTime) / 1000;
          state.transport.playheadSeconds = state.transport.basePlayheadSeconds + elapsed;
          updatePlayheadUI();
          updateRecordingPlacements();
        }
        updatePreview();
        requestAnimationFrame(tick);
      }

      function init() {
        cacheDom();
        setupEvents();
        populateResolutionOptions();
        refreshDevices().finally(() => {
          setCameraStatus('off');
          warmUpCamera();
        });
        setPanelCollapsed('bin', state.ui.binCollapsed);
        setPanelCollapsed('inspector', state.ui.inspectorCollapsed);
        dom.midiModeSelect.value = state.midi.mode;
        const midiSupported = !!navigator.requestMIDIAccess;
        if (midiSupported) {
          setMidiStatus('ready', 'MIDI Ready');
        } else {
          setMidiStatus('warn', 'MIDI Unsupported');
        }
        dom.midiConnectBtn.disabled = !midiSupported;
        dom.midiInputSelect.disabled = !midiSupported;
        dom.midiModeSelect.disabled = !midiSupported;
        if (midiSupported) {
          requestMidiAccess().then((access) => {
            if (!access) return;
            state.midi.access = access;
            state.midi.access.onstatechange = refreshMidiInputs;
            refreshMidiInputs();
          });
        }
        updateExternalMode();
        if (!state.tracks.length) {
          addTrack();
          addTrack();
        }
        renderAll();
        updateFsUi();
        requestAnimationFrame(tick);
      }

      window.addEventListener('load', init);
    })();
  </script>
</body>
</html>
